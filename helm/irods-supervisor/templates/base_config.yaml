# SPDX-FileCopyrightText: 2022 Renaissance Computing Institute. All rights reserved.
# SPDX-FileCopyrightText: 2023 Renaissance Computing Institute. All rights reserved.
#
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-License-Identifier: LicenseRef-RENCI
# SPDX-License-Identifier: MIT

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: "supervisor-scripts"
data:
  base_config.json: |-
    {
      "CLUSTER": "{{ .Values.base_config.cluster }}",
      "NAMESPACE": "{{ .Values.base_config.namespace }}",
      "DATA_PVC_CLAIM": "{{ .Values.base_config.data_pvc_claim }}",
      "SECRETS_CLAIM": "{{ .Values.base_config.secrets_claim }}",
      "CREATE_SLEEP": {{ .Values.base_config.create_sleep }},
      "JOB_TIMEOUT": {{ .Values.base_config.job_timeout }},
      "JOB_LIMIT_MULTIPLIER": "{{ .Values.base_config.job_limit_multiplier }}",
      "JOB_BACKOFF_LIMIT": {{ .Values.base_config.job_backoff_limit }},
      "SV_INACTIVITY": {{ .Values.base_config.sv_inactivity }},
      "POLL_SHORT_SLEEP": {{ .Values.base_config.poll_short_sleep }},
      "POLL_LONG_SLEEP": {{ .Values.base_config.poll_long_sleep }},
      "MAX_NO_ACTIVITY_COUNT": {{ .Values.base_config.max_no_activity_count }},
      "CPU_LIMITS": {{ .Values.cpu_limits }}
    }

  dsd.py: |-
    import sys
    import os
    import signal
    import difflib
    import subprocess
    from time import sleep

    #####################
    # Directory Size Diff (dsd.py) - program to check file system for dir/file size changes by doing before/after comparisons using the "du -k" command every second.
    # note: you may have to install the following packages:
    #####################

    # get the files that will have data to compare
    base_name = os.path.join(os.path.join(os.path.dirname(__file__), 'base-df.txt'))
    latest_name = os.path.join(os.path.join(os.path.dirname(__file__), 'latest-df.txt'))


    def sig_handler(signum, frame):
        """
        handles the <crtl> + c and cleans up.

        :param signum:
        :param frame:
        :return:
        """
        # is the file exists remove it
        if os.path.isfile(base_name):
            os.remove(base_name)

        # is the file exists remove it
        if os.path.isfile(latest_name):
            os.remove(latest_name)

        print("\nDone")
        sys.exit(0)


    # declare signal handler
    signal.signal(signal.SIGINT, sig_handler)


    def run(path):
        """
        Performs a "du -k <path>" into a file (base_file) and does it again into another file (latest_file) one second later and compares them.

        :param path - The directory to watch
        """
        with open(base_name, "w+") as base_fh:
            # run the "du -k <path>" command for the base-line data
            subprocess.run(["du", "-k", path], stdout=base_fh, stderr=base_fh, shell=True)

            # reset to the start of the file
            base_fh.seek(0)

            # save what was found
            base_text = base_fh.readlines()

            # until <ctrl> + c
            while True:
                # open a file for the latest data
                with open(latest_name, "w+") as latest_fh:
                    # run the "du -k <path>" command for the current data
                    subprocess.run(["du", "-k", path], stdout=latest_fh, stderr=latest_fh, shell=True)

                    # reset to the start of the file
                    latest_fh.seek(0)

                    # save what was found
                    latest_text = latest_fh.readlines()

                    # get the diff between the two files
                    the_diff = difflib.unified_diff(base_text, latest_text, fromfile='base data', tofile='latest data', lineterm='')

                    # init a flag that will be used for user output
                    found_diff = False

                    # for every diff discovered
                    for line in the_diff:
                        # is this the first time in
                        if not found_diff:
                            # start a new output report
                            print('--- Change detected in {p} ---'.format(p=path))
                            found_diff = True

                        # print the diff
                        print(line.rstrip('\n'))

                    # if something was found finish up the report
                    if found_diff:
                        # save this as a new base-line so any new changes will be displayed
                        base_text = latest_text
                        print('------------------\n')

                # what a second for the next try
                sleep(1)

                # remove the latest data file
                os.remove(latest_name)


    if __name__ == '__main__':
        """
        Main entry point

        Args expected --path: Path to the directory to be watched.
        """
        from argparse import ArgumentParser

        parser = ArgumentParser(description=run.__doc__)
        parser.add_argument('--path', default=None, help='Directory to watch', type=str, required=True)

        args = parser.parse_args()

        print('DataSizeDiff - Hit <ctrl> + c to exit.')
        run(args.path)



  init-irods-pg-db.sh: |-
    #!/bin/sh
    set -e

    # helpful cli to determine startup was successful
    # postgres-# \l
    # postgres-# \du
    # Check to see if the apsviz_gauge DB and user exist. if not create them
    psql -v ON_ERROR_STOP=1 --username "{{ .Values.initDB.pg_user }}" <<-EOSQL
      CREATE DATABASE "ICAT";
      CREATE ROLE "{{ .Values.initDB.user }}" WITH LOGIN SUPERUSER CREATEDB CREATEROLE INHERIT NOREPLICATION CONNECTION LIMIT -1 PASSWORD '{{ .Values.initDB.password }}';
      GRANT ALL PRIVILEGES ON DATABASE "ICAT" TO irods;
    EOSQL

  init-irods-mysql-db.sh: |-
    #!/bin/sh
    # helpful cli to determine startup was successful
    # mysql> SELECT user FROM mysql.user;
    # mysql> show databases;
    mysql -uroot -p{{ .Values.initDB.password }} -e "CREATE DATABASE ICAT; CREATE USER '{{ .Values.initDB.user }}'@'localhost'; GRANT ALL ON ICAT.* to '{{ .Values.initDB.user }}'@'localhost';"

  00-irods.conf: |-
    $FileCreateMode 0644
    $DirCreateMode 0755
    $Umask 0000
    $template irods_format,"%msg%\n"
    :programname,startswith,"irodsServer" /var/log/irods/irods.log;irods_format
    & stop
    :programname,startswith,"irodsDelayServer" /var/log/irods/irods.log;irods_format
    & stop

  irods: |-
    /var/log/irods/irods.log {
        weekly
        rotate 26
        copytruncate
        delaycompress
        compress
        dateext
        notifempty
        missingok
        su root root
    }

  irodsProviderInstall.sh: |-
    #/bin/bash
    #
    # note this has been deprecated (for now) as the consumer would never be run in core testing
    #

    # install OS updates
    apt-get update;
    apt-get -y upgrade;
    apt-get -y install irods-server irods-database-plugin-postgres jq nano;
    apt-get autoclean;

    # host names come in the form <name of job>_<id of job>_<pod guid>, ex: provider_3_wtf2u
    # break it into pieces and create hostname entries for irods and save them in a file on a shared directory.
    HN_arr=(${HOSTNAME//-/ });
    HOST_SERVICE_NAME="${HN_arr[0]}-${HN_arr[1]}"
    LOCAL_HOST_ENTRY='{"address_type": "local","addresses": ["'${HN_arr[0]}'-'${HN_arr[1]}'","'${HOSTNAME}'"]}';
    REMOTE_HOST_ENTRY='{"address_type": "remote","addresses": ["'${HN_arr[0]}'-'${HN_arr[1]}'","'${HOSTNAME}'"]}';

    echo "${LOCAL_HOST_ENTRY}" >> /data/${HN_arr[1]}/local_provider_host_entries;
    echo "${REMOTE_HOST_ENTRY}" >> /data/${HN_arr[1]}/remote_provider_host_entries;

    # do not continue until the consumer has created it's host entries file
    while [ ! -f /data/${HN_arr[1]}/remote_consumer_host_entries.sh ]; do echo "Provider waiting 5 seconds for consumer..." && sleep 5; done;

    # replace the hostname and db name in the provider initialization json
    sed 's/HOSTNAME_TEMPLATE/'"${HOST_SERVICE_NAME}"'/g' /irods/providerInit.json > /tmp/providerInit.json.1;
    sed 's/DBNAME_TEMPLATE/'"${DB_SERVICE_NAME}"'/g' /tmp/providerInit.json.1 > /tmp/providerInit.json.2;

    # add the provider host data to the init
    jq --slurpfile hosts /data/${HN_arr[1]}/local_provider_host_entries '.server_config.host_resolution.host_entries = $hosts' < /tmp/providerInit.json.2 > /tmp/providerInit.json.3;

    # if there are consumer tests presume we should add the consumer hostname to the prover config
    if [ -f /data/${HN_arr[1]}/CONSUMER_test_list.sh ]; then
      # add the contents of the host names for the consumer and provider into the provider init json
      jq --slurpfile hosts /data/${HN_arr[1]}/remote_consumer_host_entries '.server_config.host_resolution.host_entries |= .+ $hosts' < /tmp/providerInit.json.3 > /tmp/providerInit.json.4;

      # update the final provider init config
      cp /tmp/providerInit.json.4 /tmp/providerInit.json;
    else
      # update the final provider init config
      cp /tmp/providerInit.json.3 /tmp/providerInit.json;
    fi

    # setup irods and start it
    python3 /var/lib/irods/scripts/setup_irods.py --json_configuration_file /tmp/providerInit.json;
    su - irods -c './irodsctl start -v';

    # start the tests
    TEST_FILE=/data/${HN_arr[1]}/PROVIDER_test_list.sh

    # if the provider test file script exists run it
    if [ -f "$TEST_FILE" ]; then
      cd /var/lib/irods && sudo -u irods -H bash -c "/data/${HN_arr[1]}/PROVIDER_test_list.sh";
      touch /data/${HN_arr[1]}/PROVIDER_tests.complete
    fi

    # wait forever
    until false; do sleep 10000; done;

  irodsProviderCoreInstall.sh: |-
    #/bin/bash
    # install OS updates
    apt-get update;
    apt-get -y upgrade;
    apt-get -y install irods-server irods-database-plugin-postgres jq nano;
    apt-get autoclean;

    # host names come in the form <name of job>_<id of job>_<pod guid>, ex: provider_3_wtf2u
    # break it into pieces and create hostname entries for irods and save them in a file on a shared directory.
    HN_arr=(${HOSTNAME//-/ });
    HOST_SERVICE_NAME="${HN_arr[0]}-${HN_arr[1]}"
    LOCAL_HOST_ENTRY='{"address_type": "local","addresses": ["'${HN_arr[0]}'-'${HN_arr[1]}'","'${HOSTNAME}'"]}';
    REMOTE_HOST_ENTRY='{"address_type": "remote","addresses": ["'${HN_arr[0]}'-'${HN_arr[1]}'","'${HOSTNAME}'"]}';

    echo "${LOCAL_HOST_ENTRY}" >> /data/${HN_arr[1]}/local_provider_host_entries;
    echo "${REMOTE_HOST_ENTRY}" >> /data/${HN_arr[1]}/remote_provider_host_entries;

    # replace the hostname and db name in the provider initialization json
    sed 's/HOSTNAME_TEMPLATE/'"${HOST_SERVICE_NAME}"'/g' /irods/providerInit.json > /tmp/providerInit.json.1;
    sed 's/DBNAME_TEMPLATE/'"${DB_SERVICE_NAME}"'/g' /tmp/providerInit.json.1 > /tmp/providerInit.json.2;

    # add the provider host data to the init
    jq --slurpfile hosts /data/${HN_arr[1]}/local_provider_host_entries '.server_config.host_resolution.host_entries = $hosts' < /tmp/providerInit.json.2 > /tmp/providerInit.json.3;

    # update the final provider init config
    cp /tmp/providerInit.json.3 /tmp/providerInit.json;

    # setup irods and start it
    python3 /var/lib/irods/scripts/setup_irods.py --json_configuration_file /tmp/providerInit.json;
    su - irods -c './irodsctl start -v';

    # start the tests
    TEST_FILE=/data/${HN_arr[1]}/PROVIDER_test_list.sh

    # if the provider test file script exists run it
    if [ -f "$TEST_FILE" ]; then
      echo "Starting tests...";
      cd /var/lib/irods && sudo -u irods -H bash -c "/data/${HN_arr[1]}/PROVIDER_test_list.sh >> /data/${HN_arr[1]}/forensics.log";
      touch /data/${HN_arr[1]}/PROVIDER_tests.complete
      echo "Testing complete.";
    fi

    # wait forever
    until false; do sleep 10000; done;

  irodsConsumerInstall.sh: |-
    #/bin/bash
    apt-get update;
    apt-get -y upgrade;
    apt-get -y install irods-server jq nano netcat;
    apt-get autoclean;

    # host names come in the form <name of job>_<id of job>_<pod guid>, ex: consumer_3_wtf2u
    # break it into pieces and create hostname entries for irods and save them in a file on a shared directory.
    # note that this has to be done after server startup else errors will ensue
    HN_arr=(${HOSTNAME//-/ });
    HOST_SERVICE_NAME="${HN_arr[0]}-${HN_arr[1]}"
    LOCAL_HOST_ENTRY='{"address_type": "local","addresses": ["'${HN_arr[0]}'-'${HN_arr[1]}'","'${HOSTNAME}'"]}';
    REMOTE_HOST_ENTRY='{"address_type": "remote","addresses": ["'${HN_arr[0]}'-'${HN_arr[1]}'","'${HOSTNAME}'"]}';

    echo "${LOCAL_HOST_ENTRY}" >> /data/${HN_arr[1]}/local_consumer_host_entries;
    echo "${REMOTE_HOST_ENTRY}" >> /data/${HN_arr[1]}/remote_consumer_host_entries;

    # do not continue until the provider has created it's host entries file
    while [ ! -f /data/${HN_arr[1]}/remote_provider_host_entries ]; do echo "Consumer waiting for 5 seconds for provider..." && sleep 5; done;

    # replace the hostname and provider name in the consumer initialization json
    sed 's/HOSTNAME_TEMPLATE/'"${HOST_SERVICE_NAME}"'/g' /irods/consumerInit.json > /tmp/consumerInit.json.1;
    sed 's/PROVIDER_TEMPLATE/'"${PROVIDER_NAME}"'/g' /tmp/consumerInit.json.1 > /tmp/consumerInit.json.2;

    echo "provider: ${PROVIDER_NAME}";

    # add the contents of the host names for the consumer and provider into the consumer init json
    jq --slurpfile hosts /data/${HN_arr[1]}/remote_provider_host_entries '.server_config.host_resolution.host_entries = $hosts' < /tmp/consumerInit.json.2 > /tmp/consumerInit.json.3;
    jq --slurpfile hosts /data/${HN_arr[1]}/local_consumer_host_entries '.server_config.host_resolution.host_entries |= .+ $hosts' < /tmp/consumerInit.json.3 > /tmp/consumerInit.json.4;
    cp /tmp/consumerInit.json.4 /tmp/consumerInit.json;

    # here we are setting up a couple sleep loops to get around
    # a known issue with a client startup
    until nc -z ${PROVIDER_NAME} 1247
    do sleep 1; done;

    # delay some more for another service to come up
    sleep 3;

    # finally one more pause to insure we can continue
    until nc -z ${PROVIDER_NAME} 1247
    do sleep 1; done;

    echo "Provider aliveness check complete";

    # setup irods and start it
    python3 /var/lib/irods/scripts/setup_irods.py --json_configuration_file /tmp/consumerInit.json;
    su - irods -c './irodsctl start -v';

    #cd /var/lib/irods && python3 scripts/run_tests.py --run_s test_ils;
    #cd /var/lib/irods && python3 scripts/run_tests.py --xml_output --run_s test_ils;

    # start the tests
    TEST_FILE=/data/${HN_arr[1]}/CONSUMER_test_list.sh

    # if the test file exists run the tests therein
    if [ -f "$TEST_FILE" ]; then
      cd /var/lib/irods && sudo -u irods -H bash -c "/data/${HN_arr[1]}/CONSUMER_test_list.sh";
      touch /data/${HN_arr[1]}/CONSUMER_tests.complete
    fi

    until false; do sleep 10000; done;

  consumerInit.json: |-
    {
      "admin_password": "rods",
      "default_resource_directory": "/var/lib/irods/vault",
      "default_resource_name": "otherResc",
      "host_system_information": {
        "service_account_user_name": "irods",
        "service_account_group_name": "irods"
      },
      "service_account_environment": {
        "irods_client_server_negotiation": "request_server_negotiation",
        "irods_client_server_policy": "CS_NEG_REFUSE",
        "irods_connection_pool_refresh_time_in_seconds": 300,
        "irods_cwd": "/tempZone/home/rods",
        "irods_default_hash_scheme": "SHA256",
        "irods_default_number_of_transfer_threads": 4,
        "irods_default_resource": "otherResc",
        "irods_encryption_algorithm": "AES-256-CBC",
        "irods_encryption_key_size": 32,
        "irods_encryption_num_hash_rounds": 16,
        "irods_encryption_salt_size": 8,
        "irods_home": "/tempZone/home/rods",
        "irods_host": "HOSTNAME_TEMPLATE",
        "irods_match_hash_policy": "compatible",
        "irods_maximum_size_for_single_buffer_in_megabytes": 32,
        "irods_port": 1247,
        "irods_server_control_plane_encryption_algorithm": "AES-256-CBC",
        "irods_server_control_plane_encryption_num_hash_rounds": 16,
        "irods_server_control_plane_key": "32_byte_server_control_plane_key",
        "irods_server_control_plane_port": 1248,
        "irods_transfer_buffer_size_for_parallel_transfer_in_megabytes": 4,
        "irods_user_name": "rods",
        "irods_zone_name": "tempZone",
        "schema_name": "service_account_environment",
        "schema_version": "v4"
      },
      "server_config": {
        "advanced_settings": {
          "migrate_delay_server_sleep_time_in_seconds": 604800,
          "default_log_rotation_in_days": 5,
          "default_number_of_transfer_threads": 4,
          "default_temporary_password_lifetime_in_seconds": 120,
          "delay_rule_executors": [ ],
          "delay_server_sleep_time_in_seconds": 30,
          "dns_cache": {
            "eviction_age_in_seconds": 3600,
            "shared_memory_size_in_bytes": 5000000
          },
          "hostname_cache": {
            "eviction_age_in_seconds": 3600,
            "shared_memory_size_in_bytes": 2500000
          },
          "maximum_size_for_single_buffer_in_megabytes": 32,
          "maximum_size_of_delay_queue_in_bytes": 0,
          "maximum_temporary_password_lifetime_in_seconds": 7200,
          "number_of_concurrent_delay_rule_executors": 4,
          "stacktrace_file_processor_sleep_time_in_seconds": 10,
          "transfer_buffer_size_for_parallel_transfer_in_megabytes": 4,
          "transfer_chunk_size_for_parallel_transfer_in_megabytes": 40
        },
        "catalog_provider_hosts": [
          "PROVIDER_TEMPLATE"
        ],
        "catalog_service_role": "consumer",
        "client_api_allowlist_policy": "enforce",
        "controlled_user_connection_list": {
          "control_type": "denylist",
          "users": [ ]
        },
        "default_dir_mode": "0750",
        "default_file_mode": "0600",
        "default_hash_scheme": "SHA256",
        "default_resource_name": "otherResc",
        "environment_variables": { },
        "federation": [ ],
        "host_access_control": {
          "access_entries": [ ]
        },
        "host_resolution": {
          "host_entries": [ ]
        },
        "log_level": {
          "agent": "info",
          "agent_factory": "info",
          "api": "info",
          "authentication": "info",
          "database": "info",
          "delay_server": "info",
          "legacy": "info",
          "microservice": "info",
          "network": "info",
          "resource": "info",
          "rule_engine": "info",
          "server": "info"
        },
        "match_hash_policy": "compatible",
        "negotiation_key": "32_byte_server_negotiation_key__",
        "plugin_configuration": {
          "authentication": { },
          "network": { },
          "resource": { },
          "rule_engines": [
            {
              "instance_name": "irods_rule_engine_plugin-irods_rule_language-instance",
              "plugin_name": "irods_rule_engine_plugin-irods_rule_language",
              "plugin_specific_configuration": {
                "re_data_variable_mapping_set": [
                  "core"
                ],
                "re_function_name_mapping_set": [
                  "core"
                ],
                "re_rulebase_set": [
                  "core"
                ],
                "regexes_for_supported_peps": [
                  "ac[^ ]*",
                  "msi[^ ]*",
                  "[^ ]*pep_[^ ]*_(pre|post|except|finally)"
                ]
              },
              "shared_memory_instance": "irods_rule_language_rule_engine"
            },
            {
              "instance_name": "irods_rule_engine_plugin-cpp_default_policy-instance",
              "plugin_name": "irods_rule_engine_plugin-cpp_default_policy",
              "plugin_specific_configuration": { }
            }
          ]
        },
        "rule_engine_namespaces": [
          ""
        ],
        "schema_name": "server_config",
        "schema_validation_base_uri": "file:///var/lib/irods/configuration_schemas",
        "schema_version": "v4",
        "server_control_plane_encryption_algorithm": "AES-256-CBC",
        "server_control_plane_encryption_num_hash_rounds": 16,
        "server_control_plane_key": "32_byte_server_control_plane_key",
        "server_control_plane_port": 1248,
        "server_control_plane_timeout_milliseconds": 10000,
        "server_port_range_end": 20199,
        "server_port_range_start": 20000,
        "xmsg_port": 1279,
        "zone_auth_scheme": "native",
        "zone_key": "TEMPORARY_ZONE_KEY",
        "zone_name": "tempZone",
        "zone_port": 1247,
        "zone_user": "rods"
      }
    }

  providerInit.json: |-
    {
      "admin_password": "rods",
      "default_resource_directory": "/var/lib/irods/vault",
      "default_resource_name": "demoResc",
      "host_system_information": {
        "service_account_user_name": "irods",
        "service_account_group_name": "irods"
      },
      "service_account_environment": {
        "irods_client_server_negotiation": "request_server_negotiation",
        "irods_client_server_policy": "CS_NEG_REFUSE",
        "irods_connection_pool_refresh_time_in_seconds": 300,
        "irods_cwd": "/tempZone/home/rods",
        "irods_default_hash_scheme": "SHA256",
        "irods_default_number_of_transfer_threads": 4,
        "irods_default_resource": "demoResc",
        "irods_encryption_algorithm": "AES-256-CBC",
        "irods_encryption_key_size": 32,
        "irods_encryption_num_hash_rounds": 16,
        "irods_encryption_salt_size": 8,
        "irods_home": "/tempZone/home/rods",
        "irods_host": "HOSTNAME_TEMPLATE",
        "irods_match_hash_policy": "compatible",
        "irods_maximum_size_for_single_buffer_in_megabytes": 32,
        "irods_port": 1247,
        "irods_server_control_plane_encryption_algorithm": "AES-256-CBC",
        "irods_server_control_plane_encryption_num_hash_rounds": 16,
        "irods_server_control_plane_key": "32_byte_server_control_plane_key",
        "irods_server_control_plane_port": 1248,
        "irods_transfer_buffer_size_for_parallel_transfer_in_megabytes": 4,
        "irods_user_name": "rods",
        "irods_zone_name": "tempZone",
        "schema_name": "service_account_environment",
        "schema_version": "v4"
      },
      "server_config": {
        "advanced_settings": {
          "migrate_delay_server_sleep_time_in_seconds": 604800,
          "default_log_rotation_in_days": 5,
          "default_number_of_transfer_threads": 4,
          "default_temporary_password_lifetime_in_seconds": 120,
          "delay_rule_executors": ["HOSTNAME_TEMPLATE"],
          "delay_server_sleep_time_in_seconds": 30,
          "dns_cache": {
            "eviction_age_in_seconds": 3600,
            "shared_memory_size_in_bytes": 5000000
          },
          "hostname_cache": {
            "eviction_age_in_seconds": 3600,
            "shared_memory_size_in_bytes": 2500000
          },
          "maximum_size_for_single_buffer_in_megabytes": 32,
          "maximum_size_of_delay_queue_in_bytes": 0,
          "maximum_temporary_password_lifetime_in_seconds": 7200,
          "number_of_concurrent_delay_rule_executors": 4,
          "stacktrace_file_processor_sleep_time_in_seconds": 10,
          "transfer_buffer_size_for_parallel_transfer_in_megabytes": 4,
          "transfer_chunk_size_for_parallel_transfer_in_megabytes": 40
        },
        "catalog_provider_hosts": ["HOSTNAME_TEMPLATE"],
        "catalog_service_role": "provider",
        "client_api_allowlist_policy": "enforce",
        "controlled_user_connection_list": {
          "control_type": "denylist",
          "users": []
        },
        "default_dir_mode": "0750",
        "default_file_mode": "0600",
        "default_hash_scheme": "SHA256",
        "default_resource_name": "demoResc",
        "environment_variables": {},
        "federation": [],
        "host_access_control": {"access_entries": []},
        "host_resolution": {"host_entries": []},
        "log_level": {
          "agent": "trace",
          "agent_factory": "trace",
          "api": "info",
          "authentication": "info",
          "database": "info",
          "delay_server": "trace",
          "legacy": "trace",
          "microservice": "info",
          "network": "info",
          "resource": "info",
          "rule_engine": "info",
          "server": "trace",
          "sql": "info"
        },
        "match_hash_policy": "compatible",
        "negotiation_key": "32_byte_server_negotiation_key__",
        "plugin_configuration": {
          "authentication": {},
          "database": {
            "postgres": {
              "db_host": "DBNAME_TEMPLATE",
              "db_name": "ICAT",
              "db_odbc_driver": "PostgreSQL ANSI",
              "db_password": "testpassword",
              "db_port": 5432,
              "db_username": "irods"
            }
          },
          "network": {},
          "resource": {},
          "rule_engines": [
            {
              "instance_name": "irods_rule_engine_plugin-irods_rule_language-instance",
              "plugin_name": "irods_rule_engine_plugin-irods_rule_language",
              "plugin_specific_configuration": {
                "re_data_variable_mapping_set": ["core"],
                "re_function_name_mapping_set": ["core"],
                "re_rulebase_set": ["core"],
                "regexes_for_supported_peps": [
                  "ac[^ ]*",
                  "msi[^ ]*",
                  "[^ ]*pep_[^ ]*_(pre|post|except|finally)"
                ]
              },
              "shared_memory_instance": "irods_rule_language_rule_engine"
            },
            {
              "instance_name": "irods_rule_engine_plugin-cpp_default_policy-instance",
              "plugin_name": "irods_rule_engine_plugin-cpp_default_policy",
              "plugin_specific_configuration": {}
            }
          ]
        },
        "rule_engine_namespaces": [""],
        "schema_name": "server_config",
        "schema_validation_base_uri": "file:///var/lib/irods/configuration_schemas",
        "schema_version": "v4",
        "server_control_plane_encryption_algorithm": "AES-256-CBC",
        "server_control_plane_encryption_num_hash_rounds": 16,
        "server_control_plane_key": "32_byte_server_control_plane_key",
        "server_control_plane_port": 1248,
        "server_control_plane_timeout_milliseconds": 10000,
        "server_port_range_end": 20199,
        "server_port_range_start": 20000,
        "xmsg_port": 1279,
        "zone_auth_scheme": "native",
        "zone_key": "TEMPORARY_ZONE_KEY",
        "zone_name": "tempZone",
        "zone_port": 1247,
        "zone_user": "rods"
      }
    }
